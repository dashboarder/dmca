/* Euphrates / Arno
 * <rdar://problem/18528237> Euphrates: Specification and Data-sheet from Vendor (Dialog)
 *
 * NOTE: Arno is d2370
 *
 * Copyright (C) 2014 Apple Inc. All rights reserved.
 *
 * This document is the property of Apple Inc.
 * It is considered confidential and proprietary.
 *
 * This document may not be reproduced or transmitted in any form,
 * in whole or in part, without the express written permission of
 * Apple Inc.
 */

#ifndef __DIALOG_D2355_H
#define __DIALOG_D2355_H

#define PMU_HAS_SWI             0
#define PMU_HAS_DWI             0
#define PMU_HAS_LCM_LDO         0
#define PMU_HAS_BIST_ADC        0
#define PMU_HAS_CHG_ABCC_FLAG	1
#define PMU_HAS_VIB             0
#define PMU_HAS_RAM             0
#define PMU_HAS_WLED            0
#define PMU_HAS_32K_RTC         0

// TODO: enable accumulators
#define PMU_HAS_ACCUMULATORS    0

#define PMU_HAS_SYS             0
#define PMU_HAS_WDT             0
#define PMU_HAS_CHARGER         1
#define PMU_HAS_ISET_BAT_2BYTES	1
#define PMU_DRV_NEW_DRIVER      1

enum {
	kDIALOG_ADDR_R		= 0xeb,
	kDIALOG_ADDR_W		= 0xea,
	kDIALOG_REG_BYTES	= 2,
};

enum {
	kDIALOG_EVENT_COUNT     = 10,
	kDIALOG_STATUS_COUNT    = 10,
	kDIALOG_FAULTLOG_COUNT  = 3,
	kDIALOG_CHIPID_COUNT    = 9,
	kDIALOG_GPIO_COUNT      = 8,
};

#include "dCommon.h"

// ---------------------------------    
// Chip Identification
// ---------------------------------    

enum {
	kDIALOG_MASK_REV_CODE	= 0x0000,
	kDIALOG_TRIM_REL_CODE	= 0x0001,
	kDIALOG_PLATFORM_ID	= 0x0002,
	kDIALOG_PARITY		= 0x0003,
	kDIALOG_DEVICE_ID1	= 0x0004,
	kDIALOG_DEVICE_ID2	= 0x0005,
	kDIALOG_DEVICE_ID3	= 0x0006,
	kDIALOG_DEVICE_ID4	= 0x0007,
	kDIALOG_DEVICE_ID5	= 0x0008,

    kDIALOG_CHIP_ID     = kDIALOG_MASK_REV_CODE,
};

// ---------------------------------    
// System Configuration
// ---------------------------------    

// ---------------------------------    
// Faultlog (virtual)
// ---------------------------------    

enum {
	kD2355_FAULT_LOG_A	= 0x0050,
	kD2355_FAULT_LOG_B,
	kD2355_FAULT_LOG_C,	

	kDIALOG_FAULT_LOG = kD2355_FAULT_LOG_A,
};

// ---------------------------------    
// Event Register (virtual)
// ---------------------------------    

enum {
	kD2355_EVENT_A	= 0x0060,
	kD2355_EVENT_B,
	kD2355_EVENT_C,
	kD2355_EVENT_D,
	kD2355_EVENT_E,
	kD2355_EVENT_F,
	kD2355_EVENT_G,
	kD2355_EVENT_H,
	kD2355_EVENT_I,
	kD2355_EVENT_J,

	kDIALOG_EVENT_A = kD2355_EVENT_A,
};

// ---------------------------------    
// Status Register (virtual)
// ---------------------------------    

enum {
	kD2355_STATUS_A	= 0x0080,
	kD2355_STATUS_B,
	kD2355_STATUS_C,
	kD2355_STATUS_D,
	kD2355_STATUS_E,
	kD2355_STATUS_F,
	kD2355_STATUS_G,
	kD2355_STATUS_H,
	kD2355_STATUS_I,
	kD2355_STATUS_J,
	
	kDIALOG_STATUS_A = kD2355_STATUS_A,
};

// ---------------------------------    
// IRQ Mask Register (virtual)
// ---------------------------------    

enum {
	kD2355_IRQ_MASK_A	= 0x0a0,
	kD2355_IRQ_MASK_B,
	kD2355_IRQ_MASK_C,
	kD2355_IRQ_MASK_D,
	kD2355_IRQ_MASK_E,
	kD2355_IRQ_MASK_F,
	kD2355_IRQ_MASK_G,
	kD2355_IRQ_MASK_H,
	kD2355_IRQ_MASK_I,
	kD2355_IRQ_MASK_J,
	
	kDIALOG_IRQ_MASK_A = kD2355_IRQ_MASK_A,
};
// ---------------------------------    
// MAIN FSM & IRQ Control
// ---------------------------------    

enum {
	kD2355_MFSM_FAULT_LOG1 = 0x0100,
};

enum {
	kD2355_MFSM_CONF_A = 0x0140,
	kD2355_MFSM_CONF_B,
	kD2355_MFSM_CONF_C,
};

// ---------------------------------    
// GPIO: control
// ---------------------------------    

enum {
	kD2355_GPIO_GPIO1 = 0x01c0,
	kD2355_GPIO_GPIO2,
	kD2355_GPIO_GPIO3,
	kD2355_GPIO_GPIO4,
	kD2355_GPIO_GPIO5,
	kD2355_GPIO_GPIO6,
	kD2355_GPIO_GPIO7,
	kD2355_GPIO_GPIO8 = 0x01c7,
};

// ---------------------------------    
// GPIO: Event/Status/IRQ_CTL
// ---------------------------------    

// ---------------------------------    
// GPIO: Debouncer Configuration
// ---------------------------------    


// ---------------------------------    
// GPADC 
// ---------------------------------    

enum {
	kD2355_ADC_EVENT_A      = 0x0310,
	kD2355_ADC_EVENT_B,
	kD2355_ADC_EVENT_C,

	kD2355_ADC_STATUS_A     = 0x320,
	kD2355_ADC_STATUS_B,
	kD2355_ADC_STATUS_C,

	kD2355_ADC_IRQ_MASK_A   = 0x0330,
	kD2355_ADC_IRQ_MASK_B,
	kD2355_ADC_IRQ_MASK_C,
};

// ---------------------------------    
// Temperature & Sensor Control
// ---------------------------------    

enum {
    kD2355_T_OFFSET_MSB		= 0x033f,
    kD2355_T_OFFSET_LSB		= 0x0340,
};

// ---------------------------------    
// Charging Control
// ---------------------------------    

enum {
	kD2355_ADC_CHG_TRIM4 = 0x341,
	kD2355_ADC_ICHG_END,
	kD2355_ADC_TBAT_0,
	kD2355_ADC_TBAT_1,
	kD2355_ADC_TBAT_2,
	kD2355_ADC_TBAT_3,
	kD2355_ADC_TBAT_4,
	kD2355_ADC_TBAT_MAX,
	// Hysteresis, 
	// ...
	kD2355_ADC_ICHG_AVG     = 0x035e,
	kD2355_ADC_ICHG6A_AVG   = 0x035f,
	kD2355_ADC_ACTUAL_TBAT_BAND,
};

// ---------------------------------
// GPADC Control and Result
// ---------------------------------

enum {
	kD2355_ADC_CTRL1	= 0x0361,
	kD2355_ADC_RES_LSB,
	kD2355_ADC_RES_MSB,
	kD2355_ADC_CTRL2,
	kD2355_ADC_CTRL3,
	kD2355_ADC_FSM_TRIM0,
	kD2355_ADC_FSM_TRIM1,
	kD2355_ADC_FSM_TRIM2,
	kD2355_ADC_FSM_SAR,
	kD2355_ADC_ANA_TRIM0,
	kD2355_ADC_ANA_TRIM1,
};

// ---------------------------------    
// CHARGER SYSTEM 
// ---------------------------------    

// Event, Status & IRQ Control
enum {
	kD2355_CHG_EVENT_A = 0x0410,
	kD2355_CHG_EVENT_B,
	kD2355_CHG_EVENT_C,
	kD2355_CHG_EVENT_D,

	kD2355_CHG_STATUS_A = 0x0420,
	kD2355_CHG_STATUS_B,
	kD2355_CHG_STATUS_C,
	kD2355_CHG_STATUS_D,

	kD2355_CHG_IRQ_MASK_A =0x0430,
	kD2355_CHG_IRQ_MASK_B,
	kD2355_CHG_IRQ_MASK_C,
	kD2355_CHG_IRQ_MASK_D,
};

enum {
	kD2355_CHG_CTRL_A = 0x0440,
	kD2355_CHG_CTRL_B = 0x0441,
	kD2355_CHG_CTRL_C,
	kD2355_CHG_CTRL_D = 0x0443,
	kD2355_CHG_CTRL_E,
	kD2355_CHG_CTRL_F,
	
	kD2355_CHG_TIME = 0x0447,
	kD2355_CHG_TIME_PRE,

// USB Current Limit
	kD2355_CHG_ISET_BUCK 		= 0x044e,
	kD2355_CHG_ISET_BUCK_SHADOW,
	kD2355_CHG_ISET_BUCK_LV_ABSMAX,
	kD2355_CHG_ISET_BUCK_HV_ABSMAX,
	kD2355_CHG_ISET_BUCK_ACTUAL = 0x0452,
	kD2355_CHG_ISET_BUCK_ALT,
// Battery Current Limit
	kD2355_CHG_ICHG_PRE_MSB 	= 0x0454,
	kD2355_CHG_ICHG_PRE_LSB,
        kD2355_CHG_ICHG_BAT_MSB         = 0x0456,
	kD2355_CHG_ICHG_BAT_LSB,
	kD2355_CHG_ICHG_BAT_MAX_MSB     = 0x0458,
	kD2355_CHG_ICHG_BAT_MAX_LSB,
        // ??
        kD2355_CHG_ICHG_BAT_ACTUAL_MSB  = 0x045b,
        kD2355_CHG_ICHG_BAT_ACTUAL_LSB,
};

// ---------------------------------
// Misc/DEBUG
// ---------------------------------

enum {
    kDIALOG_TEST_ACCESS	= 0x0B10,
        kDIALOG_TEST_ACCESS_ENA	= 0x1D,
        kDIALOG_TEST_ACCESS_DIS	= 0x00,
};

enum {
	// <rdar://problem/21879203> J99 EVT not recognizing lightning connection
	kDIALOG_OTP_RELOAD_CONF		= kD2355_MFSM_CONF_A,
	kDIALOG_OTP_SKIP_RELOAD_TO_ACT = (1<<4),
};

// ---------------------------------
// Events
// ---------------------------------

#if 0
// Synthetic Accumulator Registers 
enum {
	kDIALOG_ACCUMULATOR_SEL_COUNT   = 2,
	kDIALOG_IBUS_ACCUMULATOR	= 0,
	kDIALOG_VBUS_ACCUMULATOR	= 1,
	kDIALOG_IBUCK0_ACCUMULATOR	= 0,
	kDIALOG_IBUCK1_ACCUMULATOR	= 0,
};
#endif

// ---------------------------------    
// Events (virtual)
// ---------------------------------    

enum {
	// 0: DEB_EVENT_A
	kD2355_EVENT_A_GPIO8		= (1 << 7),
	kD2355_EVENT_A_GPIO7		= (1 << 6),
	kD2355_EVENT_A_GPIO6		= (1 << 5),
	kD2355_EVENT_A_GPIO5		= (1 << 4),
	kD2355_EVENT_A_GPIO4		= (1 << 3),
	kD2355_EVENT_A_GPIO3		= (1 << 2),
	kD2355_EVENT_A_GPIO2		= (1 << 1),
	kD2355_EVENT_A_GPIO1		= (1 << 0),
	// 1: DEB_EVENT_B
	kD2355_EVENT_B_CHG_BG_HIGH_TEMP = (1 <<1),
	kD2355_EVENT_B_CHG_VBUS_ATT 	= (1 <<0),
	// 2: ADC_EVENT_A
	kD2355_EVENT_C_PBUS_CNT_OVERFLOW= (1 << 4),
	kD2355_EVENT_C_EOMC				= (1 << 3),
	kD2355_EVENT_C_IBUS_OVERFLOW	= (1 << 2),
	kD2355_EVENT_C_TBAT				= (1 << 1),
	kD2355_EVENT_C_VDD_LOW			= (1 << 0),
	// 3: ADC_EVENT_B
	kD2355_EVENT_D_VDDREF_CHG_FALL	= (1 << 5),
	kD2355_EVENT_D_TMID_DIE_FALL	= (1 << 4),
	kD2355_EVENT_D_TLINCHG_FALL	= (1 << 3),
	kD2355_EVENT_D_TVCENTER2_FALL	= (1 << 2),
	kD2355_EVENT_D_TVCENTER1_FALL	= (1 << 1),
	kD2355_EVENT_D_TCBUCK_FALL	= (1 << 0),
	// 4: ADC_EVENT_C
	kD2355_EVENT_E_VDDREF_CHG_RISE	= (1 << 5),
	kD2355_EVENT_E_TMID_DIE_RISE	= (1 << 4),
	kD2355_EVENT_E_TLINCHG_RISE	= (1 << 3),
	kD2355_EVENT_E_TVCENTER2_RISE	= (1 << 2),
	kD2355_EVENT_E_TVCENTER1_RISE	= (1 << 1),
	kD2355_EVENT_E_TBUCK_RISE	= (1 << 0),
	// 5: CHG_EVENT_A
	kD2355_EVENT_F_CV_LOOP_AVERAGE_SATURATED = (1 << 7),
	kD2355_EVENT_F_FAULTY_ADAPTER	= (1 << 6),
	kD2355_EVENT_F_VBUS_OV			= (1 << 5),	
	kD2355_EVENT_F_VBUS_EXT_REM		= (1 << 4),
	kD2355_EVENT_F_CHG_HV_ATT		= (1 << 3),
	kD2355_EVENT_F_VBUS_EXT_DET		= (1 << 2),
	kD2355_EVENT_F_HV_MODE			= (1 << 1),
	kD2355_EVENT_F_VCENTER_DET		= (1 << 0),
	// 6: CHG_EVENT_B
	kD2355_EVENT_G_CHG_SLOW		= (1 << 7),
	kD2355_EVENT_G_CHG_BUCK_FLG	= (1 << 6),
	kD2355_EVENT_G_CHG_ABCC_ACT	= (1 << 5),
	kD2355_EVENT_G_CHG_TIMEOUT	= (1 << 4),
	kD2355_EVENT_G_CHG_PRECHG_TIMEOUT	= (1 << 3),
	kD2355_EVENT_G_CHG_END		= (1 << 2),
	kD2355_EVENT_G_CHG_FAST		= (1 << 1),
	kD2355_EVENT_G_CHG_PRE		= (1 << 0),
	// 7: CHG_EVENT_C
	// ... kD2355_EVENT_H
	// 8: CHG_EVENT_D
	// ... kD2355_EVENT_I
	// 9: THRCTL_EVENT_A
	// ... kD2355_EVENT_J
};

enum {
	// 0: DEB_STATUS_A
	kD2355_STATUS_A_GPIO8		= (1 << 7),
	kD2355_STATUS_A_GPIO7		= (1 << 6),
	kD2355_STATUS_A_GPIO6		= (1 << 5),
	kD2355_STATUS_A_GPIO5		= (1 << 4),
	kD2355_STATUS_A_GPIO4		= (1 << 3),
	kD2355_STATUS_A_GPIO3		= (1 << 2),
	kD2355_STATUS_A_GPIO2		= (1 << 1),
	kD2355_STATUS_A_GPIO1		= (1 << 0),
	// 1: DEB_STATUS_B
	kD2355_STATUS_B_CHG_ATT 		= (1 <<7),
	kD2355_STATUS_B_CHG_BG_HIGH_TEMP = (1 <<1),
	kD2355_STATUS_B_CHG_VBUS_ATT 	= (1 <<0),
	// 2: ADC_STATUS_A
	kD2355_STATUS_C_PBUS_CNT_OVERFLOW= (1 << 3),
	kD2355_STATUS_C_IBUS_OVERFLOW	= (1 << 2),
	kD2355_STATUS_C_TBAT				= (1 << 1),
	kD2355_STATUS_C_VDD_LOW			= (1 << 0),
	// 3: ADC_STATUS_B
	kD2355_STATUS_D_VDDREF_CHG_FALL	= (1 << 5),
	kD2355_STATUS_D_TMID_DIE_FALL	= (1 << 4),
	kD2355_STATUS_D_TLINCHG_FALL	= (1 << 3),
	kD2355_STATUS_D_TVCENTER2_FALL	= (1 << 2),
	kD2355_STATUS_D_TVCENTER1_FALL	= (1 << 1),
	kD2355_STATUS_D_TCBUCK_FALL	= (1 << 0),
	// 4: ADC_STATUS_C
	kD2355_STATUS_C_VDDREF_CHG_RISE	= (1 << 5),
	kD2355_STATUS_C_TMID_DIE_RISE	= (1 << 4),
	kD2355_STATUS_C_TLINCHG_RISE	= (1 << 3),
	kD2355_STATUS_C_TVCENTER2_RISE	= (1 << 2),
	kD2355_STATUS_C_TVCENTER1_RISE	= (1 << 1),
	kD2355_STATUS_C_TBUCK_RISE	= (1 << 0),
	// 5: CHG_STATUS_A
	kD2355_STATUS_F_CV_LOOP_AVERAGE_SATURATED = (1 << 7),
	kD2355_STATUS_F_FAULTY_ADAPTER	= (1 << 6),
	kD2355_STATUS_F_VBUS_OV			= (1 << 5),	
	kD2355_STATUS_F_RES0			= (1 << 4),	
	kD2355_STATUS_F_CHG_HV_ATT		= (1 << 3),
	kD2355_STATUS_F_VBUS_EXT_DET		= (1 << 2),
	kD2355_STATUS_F_HV_MODE			= (1 << 1),
	kD2355_STATUS_F_VCENTER_DET		= (1 << 0),
	// 6: CHG_STATUS_B
	kD2355_STATUS_G_CHG_SLOW		= (1 << 7),
	kD2355_STATUS_G_CHG_BUCK_FLG	= (1 << 6),
	kD2355_STATUS_G_CHG_ABCC_ACT	= (1 << 5),
	kD2355_STATUS_G_CHG_TIMEOUT	= (1 << 4),
	kD2355_STATUS_G_CHG_PRECHG_TIMEOUT	= (1 << 3),
	kD2355_STATUS_G_CHG_END		= (1 << 2),
	kD2355_STATUS_G_CHG_FAST		= (1 << 1),
	kD2355_STATUS_G_CHG_PRE		= (1 << 0),
	// 7: CHG_STATUS_C
	// ... kD2355_STATUS_H
	// 8: CHG_STATUS_D
	// ... kD2355_STATUS_I
	// 9: THRCTL_STATUS_A
	// ... kD2355_STATUS_J
};

enum {
	kD2355_CHG_CTRL_A_TCTR_MASK		= 0xf0,
	kD2355_CHG_CTRL_A_PCTR_MASK		= 0x07,

	kD2355_CHG_CTRL_D_FORCE_VSYS_HI_UVLO 	= ( 1<<7 ),
	kD2355_CHG_CTRL_D_SW_BOOST_OFF			= ( 1<<6 ),
	kD2355_CHG_CTRL_D_BUCK_BUS_PWR_SUSPEND 	= ( 1<<5 ),
	kD2355_CHG_CTRL_D_ALT_USB_DIS1			= ( 1<<4 ),
	kD2355_CHG_CTRL_D_SUSPEND 				= ( 1<<3 ),
	kD2355_CHG_CTRL_D_BAT_PWR_SUSP			= ( 1<<2 ),
	kD2355_CHG_CTRL_D_HV_CHG_ALLOW			= ( 1<<1 ),
	kD2355_CHG_CTRL_D_OVP_DIS 				= ( 1<<0 ),

	kD2355_CHG_CTRL_E_BUCK_EN				= ( 1<<7 ),
};

enum {
// kDIALOG_CHARGE_CONTROL_EN
//  used only in iBoot to clear USB_DIS1 and allow control of usb charge limit via ISET_BUCK
//
// kDIALOG_SYS_CONTROL 
//  Here used only for kD2355_CHG_CTRL_D_BAT_PWR_SUSP
// kDIALOG_CHARGE_CONTROL_ICHG_BAT_MSB
//  Battery current limit (in charger_set_charging() )
// kDIALOG_CHARGE_BUCK_CONTROL
//  USB input current limit, used in charger_set_charging()

	kDIALOG_CHARGE_CONTROL_ICHG_BAT_MSB	= kD2355_CHG_ICHG_BAT_MSB,
	kDIALOG_OTP_ISET_BAT_MSB		    = kD2355_CHG_ICHG_BAT_MAX_MSB,
	kDIALOG_CHARGE_STATUS_MSB           = kD2355_CHG_ICHG_BAT_ACTUAL_MSB,
    
	kDIALOG_CHARGE_BUCK_CONTROL		= kD2355_CHG_ISET_BUCK,
	kDIALOG_CHARGE_BUCK_STATUS		= kD2355_CHG_ISET_BUCK_ACTUAL,

	kDIALOG_SYS_CONTROL         		= kD2355_CHG_CTRL_D,
	kDIALOG_SYS_CONTROL_BAT_PWR_SUSPEND	= kD2355_CHG_CTRL_D_BAT_PWR_SUSP,

	// masks
	kDIALOG_SYS_CONTROL_HIBERNATE_ALWAYS	= 0,
	kDIALOG_SYS_CONTROL_CHRG_CONTROLS	= kDIALOG_SYS_CONTROL_BAT_PWR_SUSPEND,

	kDIALOG_CHARGE_CONTROL_EN		= kD2355_CHG_CTRL_D,
	kDIALOG_CHARGE_CONTROL_ALT_USB_DIS      = kD2355_CHG_CTRL_D_ALT_USB_DIS1,

// for HighVoltage Charging
    kDIALOG_HV_CHG_ALLOW 		= kD2355_CHG_CTRL_D_HV_CHG_ALLOW,
    kDIALOG_HV_CHG_ALLOW_MASK 	= ( 1<<1 ),
};

enum {
// for ISET_BUCK (USB current limit)
	kDIALOG_CHARGE_BUCK_CONTROL_MIN		   		= 80,
	kDIALOG_CHARGE_BUCK_CONTROL_STEP_PER_100MA 	= 10,
	kDIALOG_CHARGE_BUCK_CONTROL_MAX		   		= 2550,

	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_MIN  = 0x08,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_100  = 0x0a,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_200  = 0x14,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_500  = 0x32,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_1000 = 0x64,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_1900 = 0xbf,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_2000 = 0xc9,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_2100 = 0xd2,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_2400 = 0xf0,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_2560 = 0xff,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_MAX  = 0xff,
	kDIALOG_CHARGE_BUCK_CONTROL_ISET_BUCK_MASK = 0xff,
};

enum {
// for ICHG_BAT (Battery Current Limit)
	kDIALOG_CHARGE_CONTROL_A_ISET_BAT_MASK	 = 0x3ff,
	kDIALOG_CHARGE_CONTROL_A_ISET_BAT_SHIFT  = 0,
	kDIALOG_OTP_ISET_BAT_SHIFT		= kDIALOG_CHARGE_CONTROL_A_ISET_BAT_SHIFT,
	kDIALOG_CHARGE_CONTROL_B_CHG_SUSP	= (1 << 5),
	kDIALOG_CHARGE_CONTROL_CHG_HIB		= 0,

	// these are ok, the one above not (not in CHARGE_CONTROL_A!!!)
	kDIALOG_CHARGE_CONTROL_ISET_BAT_MASK	 = 0x3ff,
	kDIALOG_CHARGE_CONTROL_ISET_BAT_SHIFT  = 0,

	kDIALOG_CHARGE_CONTROL_STEP		= 10,
	kDIALOG_CHARGE_CONTROL_MAX		= 6390,

};

enum {
	kDIALOG_CHARGE_CONTROL_TIME			= kD2355_CHG_CTRL_A,

	kDIALOG_CHARGE_CONTROL_TIME_TCTR_MASK	    = kD2355_CHG_CTRL_A_TCTR_MASK,
	kDIALOG_CHARGE_CONTROL_TIME_TCTR_DISABLED   = 0x00,
	kDIALOG_CHARGE_CONTROL_TIME_PCTR_MASK	    = kD2355_CHG_CTRL_A_PCTR_MASK,
	kDIALOG_CHARGE_CONTROL_TIME_PCTR_DISABLED   = 0x00,
};

// ---------------------------------    
// GPADC Control and Result
// ---------------------------------    

// channels
enum {
	kD2355_ADC_MUX_SEL_VSYS_LO = 0,
	kD2355_ADC_MUX_SEL_ICH_1A,
	kD2355_ADC_MUX_SEL_TBAT,
	kD2355_ADC_MUX_SEL_VBAT,
	kD2355_ADC_MUX_SEL_IBUS_IN_LG,
	kD2355_ADC_MUX_SEL_ADC_IN_P,
	kD2355_ADC_MUX_SEL_ADC_IN_N,
	kD2355_ADC_MUX_SEL_TJINT,
	kD2355_ADC_MUX_SEL_IBUS_IN_HG,

	kD2355_ADC_MUX_SEL_VBUS   = 10,
	kD2355_ADC_MUX_SEL_VCENTER,
	kD2355_ADC_MUX_SEL_VSYS_HI,
	kD2355_ADC_MUX_SEL_VCENTER_TEMP1,
	kD2355_ADC_MUX_SEL_LINCHG_TEMP,
	kD2355_ADC_MUX_SEL_CHG_BUCK_TEMP,
	kD2355_ADC_MUX_SEL_VCENTER_TEMP0,
	kD2355_ADC_MUX_SEL_MID_DIE_TEMP,
	kD2355_ADC_MUX_SEL_LV_LDO_TEMP  = 18,
	
	kD2355_ADC_MUX_SEL_BOOST_TEMP	= 19,
	kD2355_ADC_MUX_SEL_ICH_6A		= 29,
};

enum {
	kDIALOG_ADC_CONTROL_MUX_SEL_VDD_OUT		= kD2355_ADC_MUX_SEL_VSYS_LO, // TODO: verify
	kDIALOG_ADC_CONTROL_MUX_SEL_ICH_1A		= kD2355_ADC_MUX_SEL_ICH_1A,
	kDIALOG_ADC_CONTROL_MUX_SEL_TBAT		= kD2355_ADC_MUX_SEL_TBAT,
	kDIALOG_ADC_CONTROL_MUX_SEL_VBAT		= kD2355_ADC_MUX_SEL_VBAT,
	kDIALOG_ADC_CONTROL_MUX_SEL_IBUS_IN_LG	= kD2355_ADC_MUX_SEL_IBUS_IN_LG,
	kDIALOG_ADC_CONTROL_MUX_SEL_VIBUS		= kDIALOG_ADC_CONTROL_MUX_SEL_IBUS_IN_LG,
	kDIALOG_ADC_CONTROL_MUX_SEL_ADC_IN_P	= kD2355_ADC_MUX_SEL_ADC_IN_P,
	kDIALOG_ADC_CONTROL_MUX_SEL_ADC_IN_N	= kD2355_ADC_MUX_SEL_ADC_IN_N,
	kDIALOG_ADC_CONTROL_MUX_SEL_TJUNC		= kD2355_ADC_MUX_SEL_TJINT,
	kDIALOG_ADC_CONTROL_MUX_SEL_IBUS_IN_HG	= kD2355_ADC_MUX_SEL_IBUS_IN_HG,
	kDIALOG_ADC_CONTROL_MUX_SEL_VBUS		= kD2355_ADC_MUX_SEL_VBUS,
	kDIALOG_ADC_CONTROL_MUX_SEL_VCENTER_TEMP1	= kD2355_ADC_MUX_SEL_VCENTER_TEMP1,
	kDIALOG_ADC_CONTROL_MUX_SEL_LINCHG_TEMP		= kD2355_ADC_MUX_SEL_LINCHG_TEMP,
	kDIALOG_ADC_CONTROL_MUX_SEL_CHG_BUCK_TEMP	= kD2355_ADC_MUX_SEL_CHG_BUCK_TEMP,
	kDIALOG_ADC_CONTROL_MUX_SEL_MID_DIE_TEMP	= kD2355_ADC_MUX_SEL_MID_DIE_TEMP,
	kDIALOG_ADC_CONTROL_MUX_SEL_ICH_6A			= kD2355_ADC_MUX_SEL_ICH_6A,
	kDIALOG_ADC_CONTROL_MUX_SEL_ICH				= kD2355_ADC_MUX_SEL_ICH_1A,

	kDIALOG_ADC_CONTROL_MUX_SEL_TINT_START	= kD2355_ADC_MUX_SEL_VCENTER_TEMP1,
	kDIALOG_ADC_CONTROL_MUX_SEL_TINT_END	= kD2355_ADC_MUX_SEL_LV_LDO_TEMP,
	
	kDIALOG_ADC_CONTROL2_AUTO_VDD_OUT_EN	= (1 << 7),
	kDIALOG_ADC_CONTROL2_ICH6A_EN			= (1 << 1),
	kDIALOG_ADC_CONTROL2_IBUS_EN			= (1 << 0),

	kDIALOG_ADC_CONTROL_MAN_CONV		= (1 << 7),
	kDIALOG_ADC_CONTROL_MUX_SEL_MASK	= (0x1f << 0),
	kDIALOG_ADC_LSB_ADC_OVL				= (1 << 7),
	kDIALOG_ADC_LSB_MANADC_ERROR		= (1 << 6),

	kDIALOG_ICHG_AVG	= kD2355_ADC_ICHG_AVG,

	kDIALOG_ADC_RESOLUTION_BITS	= 12,
	kDIALOG_ADC_FULL_SCALE_MV	= 1500,
	kDIALOG_ADC_BRICK_ID_OFFSET_MV	= 40,	// TODO: verify

	kDIALOG_ADC_MAN_CTL	= kD2355_ADC_CTRL1,
	kDIALOG_ADC_CONTROL	= kD2355_ADC_CTRL1,

	kDIALOG_ADC_LSB		= kD2355_ADC_RES_LSB,
	kDIALOG_ADC_MSB		= kD2355_ADC_RES_MSB,

	kDIALOG_T_OFFSET_MSB	= kD2355_T_OFFSET_MSB,
	kDIALOG_T_OFFSET_LSB	= kD2355_T_OFFSET_LSB,
};

enum {
	kDIALOG_ADC_CONTROL_DEFAULTS	= 0,	// TODO: verify
	kDIALOG_ADC_CONTROL2_DEFAULTS	= 0,	// TODO: verify
};

// -------------------------------------------------------------------------
//
// -------------------------------------------------------------------------

enum {
	kDIALOG_SYS_GPIO_OUTPUT_LEVEL_LOW		= (0 << 1),
	kDIALOG_SYS_GPIO_OUTPUT_LEVEL_HIGH		= (1 << 1),

	kDIALOG_SYS_GPIO_DIRECTION_MASK			= (1 << 6) | (1 << 1),
	kDIALOG_SYS_GPIO_DIRECTION_OUT			= (1 << 6),
	kDIALOG_SYS_GPIO_DIRECTION_IN_LEVEL_HIGH	= (0 << 6) | (0 << 1),
	kDIALOG_SYS_GPIO_DIRECTION_IN_LEVEL_LOW		= (0 << 6) | (1 << 1),

	kDIALOG_SYS_GPIO_DIRECTION_OUT_32KHZ		= kDIALOG_SYS_GPIO_DIRECTION_OUT,   // not supported

	kDIALOG_SYS_GPIO_REG_START = kD2355_GPIO_GPIO1,
};

#define IS_GPIO_OUTPUT(gpio) (((gpio)&kDIALOG_SYS_GPIO_DIRECTION_OUT) == kDIALOG_SYS_GPIO_DIRECTION_OUT)

// -------------------------------------------------------------------------
//
// -------------------------------------------------------------------------

enum {
// N.B. index in Virtual Registers
	kDIALOG_FAULT_LOG_RST			= FAULTLOG_FLAG_MAKE(0, (1 << 3)),
	kDIALOG_FAULT_LOG_POR			= FAULTLOG_FLAG_MAKE(0, (1 << 2)),
	kDIALOG_FAULT_LOG_OVER_TEMP		= FAULTLOG_FLAG_MAKE(0, (1 << 1)),
	kDIALOG_FAULT_LOG_VDD_UNDER		= FAULTLOG_FLAG_MAKE(0, (1 << 0)),

	kDIALOG_FAULT_LOG_WDOG				= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_RESET_IN_3		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_RESET_IN_2		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_RESET_IN_1		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_BTN_SHUTDOWN		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_TWO_FINGER_RESET	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_FAULT_LOG_NTC_SHDN			= kDIALOG_NOTEXIST_MASK,
};

enum {
// N.B. index in Virtual Registers
	kDIALOG_EVENT_HOLD_BUTTON_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_MENU_BUTTON_MASK	 	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_RINGER_BUTTON_MASK 	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_BUTTON4_MASK			= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_BUTTONS_MASK			= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_PWR_BUTTON_MASK		= kDIALOG_NOTEXIST_MASK,
	
	kDIALOG_EVENT_ALARM_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_ACC_DET_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_VBUS_DET_MASK	= EVENT_FLAG_MAKE(5, kD2355_EVENT_F_VBUS_EXT_DET),
	kDIALOG_EVENT_VBUS_EXT_REM_MASK	= EVENT_FLAG_MAKE(5, kD2355_EVENT_F_VBUS_EXT_REM),
	kDIALOG_EVENT_EOMC_MASK		= EVENT_FLAG_MAKE(2, kD2355_EVENT_C_EOMC),
	kDIALOG_EVENT_HIB_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_ABCC_MASK		= EVENT_FLAG_MAKE(6, kD2355_EVENT_G_CHG_ABCC_ACT),
	
	kDIALOG_EVENT_CHG_END_MASK	= EVENT_FLAG_MAKE(6, kD2355_EVENT_G_CHG_END),
	kDIALOG_EVENT_TBAT_MASK		= EVENT_FLAG_MAKE(2, kD2355_EVENT_C_TBAT),
	
	kDIALOG_EVENT_GPIO1_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO1),
	kDIALOG_EVENT_GPIO2_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO2),
	kDIALOG_EVENT_GPIO3_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO3),
	kDIALOG_EVENT_GPIO4_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO4),
	kDIALOG_EVENT_GPIO5_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO5),
	kDIALOG_EVENT_GPIO6_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO6),
	kDIALOG_EVENT_GPIO7_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO7),
	kDIALOG_EVENT_GPIO8_MASK	= EVENT_FLAG_MAKE(0, kD2355_EVENT_A_GPIO8),
	kDIALOG_EVENT_GPIO9_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO10_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO11_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO12_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO13_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO14_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO15_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO16_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO17_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO18_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO19_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO20_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_GPIO21_MASK	= kDIALOG_NOTEXIST_MASK,

	kDIALOG_EVENT_HOLD_DBL_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_MENU_DBL_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_RINGER_DBL_MASK	= kDIALOG_NOTEXIST_MASK,

	kDIALOG_EVENT_VHP_DET_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_ON_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_EVENT_LDO2_EN_MASK	= kDIALOG_NOTEXIST_MASK,
};

enum {
// N.B. index in Virtual Registers
	kDIALOG_STATUS_USB_MASK		= STATUS_FLAG_MAKE(5, kD2355_STATUS_F_VBUS_EXT_DET),
	kDIALOG_STATUS_VBUS_MASK	= STATUS_FLAG_MAKE(5, kD2355_STATUS_F_VCENTER_DET),
	kDIALOG_STATUS_FW_MASK		= kDIALOG_NOTEXIST_MASK,
	kDIALOG_STATUS_ACC_DET_MASK	= kDIALOG_NOTEXIST_MASK,
	kDIALOG_STATUS_CHARGING_MASK	= STATUS_FLAG_MAKE(6, kD2355_EVENT_G_CHG_PRE | kD2355_EVENT_G_CHG_FAST),
	kDIALOG_STATUS_CHG_TO_MASK	= STATUS_FLAG_MAKE(6, kD2355_EVENT_G_CHG_TIMEOUT),
	kDIALOG_STATUS_CHG_END_MASK	= STATUS_FLAG_MAKE(6, kD2355_EVENT_G_CHG_END),
	kDIALOG_STATUS_TBAT_MASK	= STATUS_FLAG_MAKE(2, kD2355_STATUS_C_TBAT),
	kDIALOG_STATUS_CHG_ATT_MASK     = STATUS_FLAG_MAKE(1, kD2355_STATUS_B_CHG_ATT),
	kDIALOG_STATUS_ABCC_MASK	= STATUS_FLAG_MAKE(6, kD2355_EVENT_G_CHG_ABCC_ACT),

#define	kDIALOG_STATUS_GPIO_MASK(gpio)	  STATUS_FLAG_MAKE(0, (1 << ((gpio) % 8)))

};

static const statusRegisters kDialogStatusFWMask = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static const statusRegisters kDialogStatusChargingMask = {0, 0, 0, 0, 0, 0, kD2355_STATUS_G_CHG_PRE | kD2355_STATUS_G_CHG_FAST, 0 , 0 , 0};

enum {
	kD2355_EVENT_A_WAKEMASK = ( kD2355_EVENT_A_GPIO1 | kD2355_EVENT_A_GPIO2 | kD2355_EVENT_A_GPIO3 | kD2355_EVENT_A_GPIO4 | 
								kD2355_EVENT_A_GPIO5 | kD2355_EVENT_A_GPIO6 | kD2355_EVENT_A_GPIO7 | kD2355_EVENT_A_GPIO8 ),
	kD2355_EVENT_B_WAKEMASK = 0,
	kD2355_EVENT_C_WAKEMASK = 0,
	kD2355_EVENT_D_WAKEMASK = 0,
	kD2355_EVENT_E_WAKEMASK = 0,
	kD2355_EVENT_F_WAKEMASK = kD2355_EVENT_F_VBUS_EXT_DET | kD2355_EVENT_F_VBUS_EXT_REM | kD2355_EVENT_F_VCENTER_DET,
	kD2355_EVENT_G_WAKEMASK = kD2355_EVENT_G_CHG_TIMEOUT | kD2355_EVENT_G_CHG_PRECHG_TIMEOUT | kD2355_EVENT_G_CHG_END,
	kD2355_EVENT_H_WAKEMASK = 0,
	kD2355_EVENT_I_WAKEMASK = 0,
	kD2355_EVENT_J_WAKEMASK = 0,
};

// All events that are masked during shutdown - inverse of the wake mask,
// events that wake up the system
static const eventRegisters kDialogEventIntMasks = {
	(UInt8)~kD2355_EVENT_A_WAKEMASK, // really LLDB? really?
	~kD2355_EVENT_B_WAKEMASK,
	~kD2355_EVENT_C_WAKEMASK,
	~kD2355_EVENT_D_WAKEMASK,
	~kD2355_EVENT_E_WAKEMASK,
	~kD2355_EVENT_F_WAKEMASK,
	~kD2355_EVENT_G_WAKEMASK,
	~kD2355_EVENT_H_WAKEMASK,
	~kD2355_EVENT_I_WAKEMASK,
	~kD2355_EVENT_J_WAKEMASK,
};


// All wake events without the buttons
static const eventRegisters kDialogEventNotButtonMasks = {
	kD2355_EVENT_A_WAKEMASK,
	kD2355_EVENT_B_WAKEMASK,
	kD2355_EVENT_C_WAKEMASK,
	kD2355_EVENT_D_WAKEMASK,
	kD2355_EVENT_E_WAKEMASK,
	kD2355_EVENT_F_WAKEMASK,
	kD2355_EVENT_G_WAKEMASK,
	kD2355_EVENT_H_WAKEMASK,
	kD2355_EVENT_I_WAKEMASK,
	kD2355_EVENT_J_WAKEMASK,
};

// All events indicating external power supply
static const eventRegisters kDialogEventPwrsupplyMask = {
	0,
	0,
	0,
	0,
	0,
	kD2355_EVENT_F_VBUS_EXT_DET | kD2355_EVENT_F_VCENTER_DET,
	0,
	0,
	0,
	0,
};

static const eventRegisters kDialogEventUSBMask = {
// in d2231.h only include kD2231_EVENT_A_VBUS_EXT_DET: VCENTER can come and go while charger still usable
	0,
	0,
	0,
	0,
	0,
	kD2355_EVENT_F_VBUS_EXT_DET | kD2355_EVENT_F_VCENTER_DET,
	0, // kD2355_STATUS_G_CHG_ABCC_ACT ?
	0,
	0,
	0,
};

static const eventRegisters kDialogEventFWMask = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};

enum {
	// TODO: verify this guys
	kDialogEventPwrsupplyCount = 2,
	kDialogEventUSBCount = 2,
	kDialogEventFWCount = 0,
};

// -------------------------------------------------------------------------
//
// -------------------------------------------------------------------------


#define NUM_LDOS 0
static const struct ldo_params ldo_d2355[NUM_LDOS] = {

};
#define LDOP ldo_d2355


#endif
